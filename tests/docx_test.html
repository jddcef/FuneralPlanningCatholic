<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOCX Recreation Test Matrix</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: auto; }
        .container { border: 1px solid #ccc; padding: 15px; margin-top: 20px; border-radius: 5px; }
        .method-container { margin-bottom: 30px; }
        .matrix-selection { display: flex; justify-content: space-around; }
        .selection-group { border: 1px solid #eee; padding: 10px; border-radius: 5px; }
        h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        h3 { margin-top: 0; }
        button { font-size: 1em; padding: 10px 15px; border-radius: 5px; cursor: pointer; border: 1px solid #999; margin-top: 10px;}
        .run-btn { background-color: #28a745; color: white; border-color: #28a745; }
        label { display: block; margin-bottom: 5px; }
        #file-status { margin-top: 10px; font-style: italic; color: #555; }
        footer { margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; }
        #page-console { background-color: #333; color: #0f0; font-family: monospace; height: 200px; overflow-y: scroll; padding: 10px; border: 1px solid #555; white-space: pre-wrap; margin-top: 20px;}
    </style>
</head>
<body>
    <h1>DOCX Recreation Test Matrix</h1>
    <p>Select a .docx file. Once loaded, choose a method below to test different recreation strategies.</p>

    <div class="container">
        <h2>1. Select File</h2>
        <input type="file" id="docx-file-input" accept=".docx">
        <div id="file-status">No file selected.</div>
    </div>

    <div id="methods" class="container">
        <h2>2. Choose a Method</h2>

        <!-- Method 1: HTML Conversion -->
        <div class="method-container">
            <h3>Method 1: HTML Conversion (DOCX &rarr; HTML &rarr; DOCX/PDF)</h3>
            <p>This method converts the DOCX to HTML, then back to the selected format. Good for testing library compatibility, but may result in formatting loss.</p>
            <div class="matrix-selection">
                <div class="selection-group">
                    <h4>Readers</h4>
                    <label><input type="radio" name="html-reader" value="docx-preview" checked> docx-preview</label>
                    <label><input type="radio" name="html-reader" value="mammoth"> mammoth.js</label>
                </div>
                <div class="selection-group">
                    <h4>Writers</h4>
                    <label><input type="radio" name="html-writer" value="html-docx-js" checked> html-docx-js</label>
                    <label><input type="radio" name="html-writer" value="docxjs"> docx.js</label>
                    <label><input type="radio" name="html-writer" value="docxtemplater"> docxtemplater</label>
                </div>
                <div class="selection-group">
                    <h4>Output Format</h4>
                    <label><input type="radio" name="html-format" value="docx" checked> DOCX</label>
                    <label><input type="radio" name="html-format" value="pdf"> PDF</label>
                </div>
            </div>
            <button id="run-html-test-btn" class="run-btn">Run HTML Conversion Test</button>
        </div>

        <hr>

        <!-- Method 2: High-Fidelity Pass-Through -->
        <div class="method-container">
            <h3>Method 2: High-Fidelity Pass-Through (DOCX &rarr; Internal Model &rarr; DOCX)</h3>
            <p>This method loads the DOCX into a library's internal model and saves it again. This is the best method for testing formatting retention.</p>
            <button id="run-docx4js-passthrough-btn" class="run-btn">Run docx4js Pass-Through</button>
            <button id="run-docxjs-passthrough-btn" class="run-btn">Run docx.js Pass-Through</button>
        </div>
    </div>

    <div class="container">
        <h2>Intermediate HTML Output</h2>
        <div id="html-output" style="height: 200px; overflow-y: scroll; border: 1px solid #eee; padding: 10px; background: #f8f8f8;">
            <!-- Intermediate HTML will be shown here -->
        </div>
    </div>

    <div class="container">
        <h2>Debug Console</h2>
        <div id="page-console"></div>
    </div>

    <footer>
        Test Page Version: v1.0.5
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const fileInput = document.getElementById('docx-file-input');
            const fileStatus = document.getElementById('file-status');
            const pageConsole = document.getElementById('page-console');
            const runHtmlTestBtn = document.getElementById('run-html-test-btn');
            const runDocx4jsPassthroughBtn = document.getElementById('run-docx4js-passthrough-btn');
            const runDocxjsPassthroughBtn = document.getElementById('run-docxjs-passthrough-btn');
            const htmlOutput = document.getElementById('html-output');

            let fileDataURL = null;
            const loadedScripts = {};

            function log(message) {
                const time = new Date().toLocaleTimeString();
                pageConsole.innerHTML += `[${time}] ${message}\n`;
                pageConsole.scrollTop = pageConsole.scrollHeight;
            }

            log("Page loaded and script initialized.");

            function loadScript(url) {
                if (loadedScripts[url]) {
                    log(`Script already loaded: ${url}`);
                    return Promise.resolve();
                }
                log(`Loading script: ${url}`);
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = () => {
                        log(`Script loaded successfully: ${url}`);
                        loadedScripts[url] = true;
                        resolve();
                    };
                    script.onerror = () => {
                        log(`Error loading script: ${url}`);
                        reject(new Error(`Script load error for ${url}`));
                    };
                    document.head.appendChild(script);
                });
            }

            fileInput.addEventListener('change', function (event) {
                log("File input 'change' event fired.");
                const file = event.target.files[0];
                if (!file) {
                    log("No file found in event. Resetting.");
                    fileDataURL = null;
                    fileStatus.textContent = "No file selected.";
                    return;
                }
                log(`File object found: ${file.name}. Reading file...`);
                const reader = new FileReader();
                reader.onload = (e) => {
                    fileDataURL = e.target.result;
                    fileStatus.textContent = `File loaded: ${file.name}`;
                    log("File successfully read into memory as Data URL.");
                };
                reader.onerror = () => {
                    fileDataURL = null;
                    fileStatus.textContent = "Error loading file.";
                    log("Error reading file with FileReader.");
                };
                reader.readAsDataURL(file);
            });

            function dataURLtoArrayBuffer(dataurl) {
                log("Converting Data URL to ArrayBuffer...");
                const parts = dataurl.split(',');
                const byteString = atob(parts[1]);
                const buffer = new ArrayBuffer(byteString.length);
                const a = new Uint8Array(buffer);
                for (let i = 0; i < byteString.length; i++) {
                    a[i] = byteString.charCodeAt(i);
                }
                log("Conversion complete.");
                return buffer;
            }

            const getFileAsArrayBuffer = () => {
                log("Attempting to get file as ArrayBuffer...");
                if (!fileDataURL) {
                    log("No file data found. Alerting user.");
                    alert("Please select a file first. The 'File loaded' message should appear below the selector.");
                    return Promise.reject(new Error("No file loaded"));
                }
                log("File data found. Proceeding with conversion.");
                return Promise.resolve(dataURLtoArrayBuffer(fileDataURL));
            };

            runHtmlTestBtn.addEventListener('click', async () => {
                log("'Run HTML Conversion Test' button clicked.");
                try {
                    const reader = document.querySelector('input[name="html-reader"]:checked').value;
                    const writer = document.querySelector('input[name="html-writer"]:checked').value;
                    const format = document.querySelector('input[name="html-format"]:checked').value;
                    const arrayBuffer = await getFileAsArrayBuffer();
                    log(`Running HTML test with Reader: ${reader}, Writer: ${writer}, Format: ${format}`);
                    const html = await runHtmlReader(reader, arrayBuffer);
                    htmlOutput.innerHTML = html;
                    log("Intermediate HTML rendered.");
                    const fileName = `recreated-html-${reader}-${writer}.${format}`;
                    if (format === 'pdf') {
                        await runPdfWriter(html, fileName);
                    } else {
                        await runHtmlWriter(writer, html, fileName);
                    }
                    log("Test complete.");
                } catch (err) {
                    log(`Error in HTML Conversion Test: ${err.message}`);
                    if (err.message !== "No file loaded") {
                        alert(`An error occurred: ${err.message}`);
                    }
                }
            });

            runDocx4jsPassthroughBtn.addEventListener('click', async () => {
                log("'Run docx4js Pass-Through' button clicked.");
                try {
                    const arrayBuffer = await getFileAsArrayBuffer();
                    log("Running docx4js pass-through test.");
                    const { default: docx4js } = await import('https://cdn.jsdelivr.net/npm/docx4js@3.1.1/dist/docx4js.js');
                    const doc = await docx4js.load(arrayBuffer);
                    log("docx4js object loaded.");
                    htmlOutput.textContent = 'Pass-through test does not generate HTML.';
                    const blob = await doc.save();
                    log("docx4js save complete. Triggering download.");
                    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js');
                    window.saveAs(blob, 'recreated-passthrough-docx4js.docx');
                    log("Test complete.");
                } catch (err) {
                    log(`Error in docx4js Pass-through Test: ${err.message}`);
                    if (err.message !== "No file loaded") {
                        alert(`An error occurred: ${err.message}`);
                    }
                }
            });

            runDocxjsPassthroughBtn.addEventListener('click', async () => {
                log("'Run docx.js Pass-Through' button clicked.");
                try {
                    const arrayBuffer = await getFileAsArrayBuffer();
                    log("Running docx.js pass-through test.");
                    await loadScript('https://cdn.jsdelivr.net/npm/docx@9.5.1/dist/index.iife.js');
                    htmlOutput.textContent = 'Pass-through test does not generate HTML.';
                    const blob = await window.docx.patchDocument({
                        outputType: "blob",
                        data: arrayBuffer,
                        patches: {},
                    });
                    log("docx.js patch complete. Triggering download.");
                    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js');
                    window.saveAs(blob, 'recreated-passthrough-docxjs.docx');
                    log("Test complete.");
                } catch (err) {
                    log(`Error in docx.js Pass-through Test: ${err.message}`);
                    if (err.message !== "No file loaded") {
                        alert(`An error occurred: ${err.message}`);
                    }
                }
            });

            async function runHtmlReader(reader, arrayBuffer) {
                log(`Running HTML Reader: ${reader}...`);
                await loadScript('https://unpkg.com/jszip/dist/jszip.min.js');
                const container = document.createElement('div');
                switch (reader) {
                    case 'docx-preview':
                        await loadScript('https://cdn.jsdelivr.net/npm/docx-preview@0.1.13/dist/docx-preview.min.js');
                        // This script creates a window.docx, so we rename it
                        if(!window.docxPreview) window.docxPreview = window.docx;
                        return window.docxPreview.renderAsync(arrayBuffer, container)
                            .then(() => {
                                log("docx-preview finished.");
                                return container.innerHTML;
                            });
                    case 'mammoth':
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.10.0/mammoth.browser.min.js');
                        return window.mammoth.convertToHtml({ arrayBuffer })
                            .then(result => {
                                log("mammoth.js finished.");
                                return result.value;
                            });
                    default:
                        return Promise.reject(new Error(`HTML Reader not implemented: ${reader}`));
                }
            }

            async function runPdfWriter(html, fileName) {
                log("Running PDF Writer (jsPDF)...");
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                const container = document.createElement('div');
                container.innerHTML = html;
                document.body.appendChild(container);

                const canvas = await window.html2canvas(container, { useCORS: true });
                log("html2canvas finished. Creating PDF...");
                document.body.removeChild(container);
                const imgData = canvas.toDataURL('image/png');
                const imgProps = pdf.getImageProperties(imgData);
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
                pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
                pdf.save(fileName);
                log("PDF saved.");
            }

            async function runHtmlWriter(writer, html, fileName) {
                log(`Running HTML Writer: ${writer}...`);
                 await loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js');
                switch (writer) {
                    case 'docxtemplater':
                        await loadScript('https://cdn.jsdelivr.net/npm/docx@9.5.1/dist/index.iife.js');
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/pizzip/3.1.4/pizzip.min.js');
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/docxtemplater/3.31.2/docxtemplater.js');
                        const templateDoc = new window.docx.Document({
                            sections: [{ children: [new window.docx.Paragraph(new window.docx.TextRun("{content}"))] }],
                        });
                        const templateBlob = await window.docx.Packer.toBlob(templateDoc);
                        const templateBuffer = await templateBlob.arrayBuffer();
                        const zip = new window.PizZip(templateBuffer);
                        const doc = new window.docxtemplater(zip);
                        doc.render({ content: html });
                        const out = doc.getZip().generate({ type: 'blob' });
                        window.saveAs(out, fileName);
                        log("docxtemplater finished.");
                        break;
                    case 'html-docx-js':
                        await loadScript('https://unpkg.com/html-docx-js/dist/html-docx.js');
                        const simplifiedHtml = html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
                        var converted = window.htmlDocx.asBlob(simplifiedHtml);
                        window.saveAs(converted, fileName);
                        log("html-docx-js finished.");
                        break;
                    case 'docxjs':
                         await loadScript('https://cdn.jsdelivr.net/npm/docx@9.5.1/dist/index.iife.js');
                        const parser = new DOMParser();
                        const htmlDoc = parser.parseFromString(html, 'text/html');
                        const paragraphs = Array.from(htmlDoc.querySelectorAll('p')).map(p =>
                            new window.docx.Paragraph({ children: [new window.docx.TextRun(p.textContent)] })
                        );
                        const newDoc = new window.docx.Document({ sections: [{ children: paragraphs }] });
                        const blob = await window.docx.Packer.toBlob(newDoc);
                        window.saveAs(blob, fileName);
                        log("docx.js finished.");
                        break;
                    default:
                        throw new Error(`HTML Writer not implemented: ${writer}`);
                }
            }
        });
    </script>
</body>
</html>
