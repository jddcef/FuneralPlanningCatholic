<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOCX Recreation Test Matrix</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: auto; }
        .container { border: 1px solid #ccc; padding: 15px; margin-top: 20px; border-radius: 5px; }
        .method-container { margin-bottom: 30px; }
        .matrix-selection { display: flex; justify-content: space-around; }
        .selection-group { border: 1px solid #eee; padding: 10px; border-radius: 5px; }
        h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        h3 { margin-top: 0; }
        button { font-size: 1em; padding: 10px 15px; border-radius: 5px; cursor: pointer; border: 1px solid #999; margin-top: 10px;}
        .run-btn { background-color: #28a745; color: white; border-color: #28a745; }
        label { display: block; margin-bottom: 5px; }
        input[type="text"] { padding: 5px; width: 200px; }
        #file-status { margin-top: 10px; font-style: italic; color: #555; }
        footer { margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; }
        #page-console { background-color: #333; color: #0f0; font-family: monospace; height: 200px; overflow-y: scroll; padding: 10px; border: 1px solid #555; white-space: pre-wrap; margin-top: 20px;}
        .disabled-feature { color: #999; text-decoration: line-through; }
        .preview-container { display: flex; gap: 20px; }
        .preview-box { flex: 1; border: 1px solid #eee; padding: 10px; height: 300px; overflow-y: scroll; }
    </style>
</head>
<body>
    <h1>DOCX Recreation Test Matrix</h1>
    <p>Select a .docx file. Once loaded, choose a method below to test different recreation strategies.</p>

    <div class="container">
        <h2>1. Select File</h2>
        <input type="file" id="docx-file-input" accept=".docx">
        <div id="file-status">No file selected.</div>
    </div>

    <div class="container">
        <h2>Document Previews</h2>
        <div class="preview-container">
            <div class="preview-box">
                <h4>Preview (from docx-preview.js)</h4>
                <div id="docx-preview-output"></div>
            </div>
            <div class="preview-box">
                <h4>Preview (from mammoth.js)</h4>
                <div id="mammoth-output"></div>
            </div>
        </div>
    </div>

    <div id="methods" class="container">
        <h2>2. Choose a Method</h2>

        <!-- Method 1: HTML Conversion -->
        <div class="method-container">
            <h3>Method 1: HTML Conversion (DOCX &rarr; HTML &rarr; DOCX/PDF)</h3>
            <p>This method converts the DOCX to HTML, then back to the selected format. Good for testing library compatibility, but may result in formatting loss.</p>
            <div class="matrix-selection">
                <div class="selection-group">
                    <h4>Readers</h4>
                    <label><input type="radio" name="html-reader" value="docx-preview" checked> docx-preview</label>
                    <label><input type="radio" name="html-reader" value="mammoth"> mammoth.js</label>
                </div>
                <div class="selection-group">
                    <h4>Writers</h4>
                    <label><input type="radio" name="html-writer" value="html-docx-js" checked> html-docx-js</label>
                    <label><input type="radio" name="html-writer" value="docxjs"> docx.js</label>
                    <label><input type="radio" name="html-writer" value="docxtemplater"> docxtemplater <span class="warning-note">(No HTML support)</span></label>
                </div>
                <div class="selection-group">
                    <h4>Output Format</h4>
                    <label><input type="radio" name="html-format" value="docx" checked> DOCX</label>
                    <label><input type="radio" name="html-format" value="pdf"> PDF</label>
                </div>
            </div>
            <button id="run-html-test-btn" class="run-btn">Run HTML Conversion Test</button>
        </div>

        <hr>

        <!-- Method 2: High-Fidelity Pass-Through -->
        <div class="method-container">
            <h3>Method 2: High-Fidelity Pass-Through (DOCX &rarr; Internal Model &rarr; DOCX)</h3>
            <p>This method loads the DOCX into a library's internal model and saves it again. This is the best method for testing formatting retention.</p>
            <button id="run-docxjs-passthrough-btn" class="run-btn">Run docx.js Pass-Through</button>
            <span class="disabled-feature">(docx4js is unavailable due to browser compatibility issues)</span>
        </div>

        <hr>

        <!-- Method 3: Pass-Through with Modification -->
        <div class="method-container">
            <h3>Method 3: Pass-Through with Placeholder Replace</h3>
            <p>This method uses the <code>docx.js</code> library to find and replace placeholders in the document.</p>
            <div>
                <label for="find-text">Placeholder to Find (e.g., <code>my_placeholder</code> for <code>{{my_placeholder}}</code>):</label>
                <input type="text" id="find-text" value="the">
            </div>
            <div style="margin-top: 10px;">
                <label for="replace-text">Replacement Text:</label>
                <input type="text" id="replace-text" value="zzz">
            </div>
            <button id="run-replace-test-btn" class="run-btn">Run docx.js Find &amp; Replace</button>
        </div>
    </div>

    <div class="container">
        <h2>Debug Console</h2>
        <div id="page-console"></div>
    </div>

    <footer>
        Test Page Version: v1.1.0
    </footer>

    <script src="https://unpkg.com/jszip/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx-preview@0.1.13/dist/docx-preview.min.js"></script>
    <script>
      window.docxPreview = window.docx;
    </script>
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx@9.5.1/dist/index.iife.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.10.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pizzip/3.1.4/pizzip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docxtemplater/3.31.2/docxtemplater.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const fileInput = document.getElementById('docx-file-input');
            const fileStatus = document.getElementById('file-status');
            const pageConsole = document.getElementById('page-console');
            const runHtmlTestBtn = document.getElementById('run-html-test-btn');
            const runDocxjsPassthroughBtn = document.getElementById('run-docxjs-passthrough-btn');
            const runReplaceTestBtn = document.getElementById('run-replace-test-btn');
            const findTextInput = document.getElementById('find-text');
            const replaceTextInput = document.getElementById('replace-text');
            const docxPreviewOutput = document.getElementById('docx-preview-output');
            const mammothOutput = document.getElementById('mammoth-output');

            let fileDataURL = null;

            function log(message) {
                const time = new Date().toLocaleTimeString();
                pageConsole.innerHTML += `[${time}] ${message}\n`;
                pageConsole.scrollTop = pageConsole.scrollHeight;
            }

            log("Page loaded and script initialized.");

            fileInput.addEventListener('change', async function (event) {
                log("File input 'change' event fired.");
                const file = event.target.files[0];
                if (!file) {
                    log("No file found in event. Resetting.");
                    fileDataURL = null;
                    fileStatus.textContent = "No file selected.";
                    return;
                }
                log(`File object found: ${file.name}. Reading file...`);
                const reader = new FileReader();
                reader.onload = async (e) => {
                    fileDataURL = e.target.result;
                    fileStatus.textContent = `File loaded: ${file.name}`;
                    log("File successfully read into memory as Data URL.");

                    // Render previews automatically
                    log("Rendering previews...");
                    const arrayBuffer = dataURLtoArrayBuffer(fileDataURL);
                    try {
                        const mammothHtml = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer.slice(0) });
                        mammothOutput.innerHTML = mammothHtml.value;
                        log("Mammoth.js preview rendered.");
                    } catch (err) {
                        log(`Mammoth.js preview failed: ${err.message}`);
                        mammothOutput.innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
                    }
                    try {
                        await docxPreview.renderAsync(arrayBuffer.slice(0), docxPreviewOutput);
                        log("docx-preview finished.");
                    } catch (err) {
                        log(`docx-preview failed: ${err.message}`);
                        docxPreviewOutput.innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
                    }
                };
                reader.onerror = () => {
                    fileDataURL = null;
                    fileStatus.textContent = "Error loading file.";
                    log("Error reading file with FileReader.");
                };
                reader.readAsDataURL(file);
            });

            function dataURLtoArrayBuffer(dataurl) {
                log("Converting Data URL to ArrayBuffer...");
                const parts = dataurl.split(',');
                const byteString = atob(parts[1]);
                const buffer = new ArrayBuffer(byteString.length);
                const a = new Uint8Array(buffer);
                for (let i = 0; i < byteString.length; i++) {
                    a[i] = byteString.charCodeAt(i);
                }
                log("Conversion complete.");
                return buffer;
            }

            const getFileAsArrayBuffer = () => {
                log("Attempting to get file as ArrayBuffer...");
                if (!fileDataURL) {
                    log("No file data found. Alerting user.");
                    alert("Please select a file first. The 'File loaded' message should appear below the selector.");
                    return Promise.reject(new Error("No file loaded"));
                }
                log("File data found. Proceeding with conversion.");
                return Promise.resolve(dataURLtoArrayBuffer(fileDataURL));
            };

            runHtmlTestBtn.addEventListener('click', async () => {
                log("'Run HTML Conversion Test' button clicked.");
                try {
                    const reader = document.querySelector('input[name="html-reader"]:checked').value;
                    const writer = document.querySelector('input[name="html-writer"]:checked').value;
                    const format = document.querySelector('input[name="html-format"]:checked').value;
                    const arrayBuffer = await getFileAsArrayBuffer();
                    log(`Running HTML test with Reader: ${reader}, Writer: ${writer}, Format: ${format}`);
                    const html = await runHtmlReader(reader, arrayBuffer);
                    log("Intermediate HTML generated for test.");
                    const fileName = `recreated-html-${reader}-${writer}.${format}`;
                    if (format === 'pdf') {
                        await runPdfWriter(html, fileName);
                    } else {
                        await runHtmlWriter(writer, html, fileName);
                    }
                    log("Test complete.");
                } catch (err) {
                    log(`Error in HTML Conversion Test: ${err.message}`);
                    if (err.message !== "No file loaded") {
                        alert(`An error occurred: ${err.message}`);
                    }
                }
            });

            runDocxjsPassthroughBtn.addEventListener('click', async () => {
                log("'Run docx.js Pass-Through' button clicked.");
                try {
                    const arrayBuffer = await getFileAsArrayBuffer();
                    log("Running docx.js pass-through test.");
                    const blob = await docx.patchDocument({
                        outputType: "blob",
                        data: arrayBuffer,
                        patches: {},
                    });
                    log("docx.js patch complete. Triggering download.");
                    saveAs(blob, 'recreated-passthrough-docxjs.docx');
                    log("Test complete.");
                } catch (err) {
                    log(`Error in docx.js Pass-through Test: ${err.message}`);
                    if (err.message !== "No file loaded") {
                        alert(`An error occurred: ${err.message}`);
                    }
                }
            });

            runReplaceTestBtn.addEventListener('click', async () => {
                log("'Run docx.js Find & Replace' button clicked.");
                try {
                    const findText = findTextInput.value;
                    const replaceText = replaceTextInput.value;
                    if (!findText) {
                        alert("Please enter text to find.");
                        return;
                    }

                    const arrayBuffer = await getFileAsArrayBuffer();
                    log(`Running docx.js find & replace test. Finding: "${findText}", Replacing with: "${replaceText}"`);

                    const patches = {
                        [findText]: {
                            type: docx.PatchType.PARAGRAPH,
                            children: [new docx.TextRun(replaceText)],
                        },
                    };

                    const blob = await docx.patchDocument({
                        outputType: "blob",
                        data: arrayBuffer,
                        patches: patches,
                    });
                    log("docx.js patch complete. Triggering download.");
                    saveAs(blob, `recreated-replace-${findText}.docx`);
                    log("Test complete.");
                } catch (err) {
                    log(`Error in docx.js Find & Replace Test: ${err.message}`);
                    if (err.message !== "No file loaded") {
                        alert(`An error occurred: ${err.message}`);
                    }
                }
            });

            function runHtmlReader(reader, arrayBuffer) {
                log(`Running HTML Reader: ${reader}...`);
                const container = document.createElement('div');
                switch (reader) {
                    case 'docx-preview':
                        return docxPreview.renderAsync(arrayBuffer, container)
                            .then(() => {
                                log("docx-preview finished.");
                                return container.innerHTML;
                            });
                    case 'mammoth':
                        return mammoth.convertToHtml({ arrayBuffer })
                            .then(result => {
                                log("mammoth.js finished.");
                                return result.value;
                            });
                    default:
                        return Promise.reject(new Error(`HTML Reader not implemented: ${reader}`));
                }
            }

            function runPdfWriter(html, fileName) {
                log("Running PDF Writer (jsPDF)...");
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                const container = document.createElement('div');
                container.innerHTML = html;
                document.body.appendChild(container);

                return window.html2canvas(container, { useCORS: true }).then(canvas => {
                    log("html2canvas finished. Creating PDF...");
                    document.body.removeChild(container);
                    const imgData = canvas.toDataURL('image/png');
                    const imgProps = pdf.getImageProperties(imgData);
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
                    pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
                    pdf.save(fileName);
                    log("PDF saved.");
                });
            }

            function runHtmlWriter(writer, html, fileName) {
                log(`Running HTML Writer: ${writer}...`);
                switch (writer) {
                    case 'docxtemplater':
                        const templateDoc = new docx.Document({
                            sections: [{ children: [new docx.Paragraph({children: [new docx.TextRun("{content}")
                            ]})] }],
                        });
                        return docx.Packer.toBlob(templateDoc).then(templateBlob => {
                            return new Promise((resolve, reject) => {
                                const fr = new FileReader();
                                fr.onload = () => {
                                    try {
                                        const zip = new PizZip(fr.result);
                                        const doc = new docxtemplater(zip);
                                        doc.render({ content: html });
                                        const out = doc.getZip().generate({ type: 'blob' });
                                        saveAs(out, fileName);
                                        log("docxtemplater finished.");
                                        resolve();
                                    } catch (error) {
                                        log(`docxtemplater error: ${error.message}`);
                                        reject(error);
                                    }
                                };
                                fr.onerror = (e) => {
                                    log(`FileReader error for docxtemplater template: ${e}`);
                                    reject(e);
                                }
                                fr.readAsArrayBuffer(templateBlob);
                            });
                        });
                    case 'html-docx-js':
                        const simplifiedHtml = html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
                        var converted = htmlDocx.asBlob(simplifiedHtml);
                        saveAs(converted, fileName);
                        log("html-docx-js finished.");
                        return Promise.resolve();
                    case 'docxjs':
                        const parser = new DOMParser();
                        const htmlDoc = parser.parseFromString(html, 'text/html');
                        const paragraphs = Array.from(htmlDoc.querySelectorAll('p')).map(p =>
                            new docx.Paragraph({ children: [new docx.TextRun(p.textContent)] })
                        );
                        const newDoc = new docx.Document({ sections: [{ children: paragraphs }] });
                        return docx.Packer.toBlob(newDoc).then(blob => {
                            saveAs(blob, fileName);
                            log("docx.js finished.");
                        });
                    default:
                        return Promise.reject(new Error(`HTML Writer not implemented: ${writer}`));
                }
            }
        });
    </script>
</body>
</html>
